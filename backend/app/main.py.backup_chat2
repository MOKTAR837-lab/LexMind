# app/main.py
from app.chat_handler import ChatHandler
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, UploadFile, File, Form, HTTPException, Response, Query
from fastapi.middleware.cors import CORSMiddleware
from typing import Optional, List, Dict, Any
from sqlalchemy import text
from app.db import ping_db, engine
import base64

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"],
)

# --- bootstrap schéma minimal (dossiers + lien sur documents) ---
@app.on_event("startup")
def ensure_schema() -> None:
    with engine.begin() as conn:
        conn.execute(text("""
        CREATE TABLE IF NOT EXISTS folders (
          id BIGSERIAL PRIMARY KEY,
          name TEXT NOT NULL,
          parent_id BIGINT REFERENCES folders(id) ON DELETE SET NULL,
          created_at TIMESTAMPTZ DEFAULT now()
        );
        """))
        conn.execute(text("""
        ALTER TABLE documents
          ADD COLUMN IF NOT EXISTS folder_id BIGINT REFERENCES folders(id) ON DELETE SET NULL;
        """))
        conn.execute(text("CREATE INDEX IF NOT EXISTS idx_documents_folder_id ON documents(folder_id);"))

# --- santé / ping DB ---
@app.get("/health")
def health():
    return {"status": "ok"}

@app.get("/db-check")
def db_check():
    return {"ok": ping_db()}

@app.websocket("/ws/chat/{user_id}")
async def ws_chat(websocket: WebSocket, user_id: str):
    await websocket.accept()
    try:
        while True:
            msg = await websocket.receive_text()
            
            # Récupérer les dossiers
            with engine.connect() as conn:
                result = conn.execute(text("SELECT id, name, parent_id FROM folders"))
                folders = [dict(row._mapping) for row in result]
            
            # Traiter le message
            response = await chat_handler.process_message(msg, folders)
            await websocket.send_text(response)
    except WebSocketDisconnect:
        return

# ---------------------- FOLDERS API ----------------------
@app.post("/folders")
def create_folder(name: str = Form(...), parent_id: Optional[int] = Form(None)) -> Dict[str, Any]:
    with engine.begin() as conn:
        row = conn.execute(
            text("""INSERT INTO folders(name, parent_id)
                    VALUES(:n, :p)
                    RETURNING id, name, parent_id, created_at"""),
            {"n": name, "p": parent_id},
        ).mappings().one()
        return dict(row)

@app.get("/folders")
def list_folders(parent_id: Optional[int] = Query(None)) -> List[Dict[str, Any]]:
    with engine.begin() as conn:
        if parent_id is None:
            rs = conn.execute(
                text("""SELECT id, name, parent_id, created_at
                        FROM folders
                        WHERE parent_id IS NULL
                        ORDER BY id""")
            ).mappings().all()
        else:
            rs = conn.execute(
                text("""SELECT id, name, parent_id, created_at
                        FROM folders
                        WHERE parent_id = :p
                        ORDER BY id"""),
                {"p": parent_id},
            ).mappings().all()
        return [dict(r) for r in rs]

@app.get("/folders/{folder_id}")
def get_folder(folder_id: int) -> Dict[str, Any]:
    with engine.begin() as conn:
        row = conn.execute(
            text("""SELECT id, name, parent_id, created_at
                    FROM folders WHERE id=:i"""),
            {"i": folder_id},
        ).mappings().first()
        if not row:
            raise HTTPException(404, "Folder not found")
        return dict(row)

# ---------------------- DOCUMENTS API ----------------------
@app.post("/documents/upload")
async def upload_document(
    folder_id: Optional[int] = Form(None),
    file: UploadFile = File(...),
) -> Dict[str, Any]:
    raw = await file.read()
    # On stocke en texte. Si non-UTF8, on met 'base64:' + base64(data).
    try:
        content_txt = raw.decode("utf-8")
    except UnicodeDecodeError:
        content_txt = "base64:" + base64.b64encode(raw).decode("ascii")

    with engine.begin() as conn:
        # Optionnel: valider le dossier
        if folder_id is not None:
            exists = conn.execute(text("SELECT 1 FROM folders WHERE id=:i"), {"i": folder_id}).scalar()
            if not exists:
                raise HTTPException(400, "folder_id invalide")

        row = conn.execute(
            text("""INSERT INTO documents(filename, mime, content, folder_id)
                    VALUES(:fn, :mt, :ct, :fid)
                    RETURNING id, filename, mime, folder_id, created_at"""),
            {"fn": file.filename, "mt": file.content_type, "ct": content_txt, "fid": folder_id},
        ).mappings().one()
        return dict(row)

@app.get("/folders/{folder_id}/documents")
def list_documents(folder_id: int) -> List[Dict[str, Any]]:
    with engine.begin() as conn:
        rs = conn.execute(
            text("""SELECT id, filename, mime, created_at
                    FROM documents
                    WHERE folder_id = :f
                    ORDER BY id DESC"""),
            {"f": folder_id},
        ).mappings().all()
        return [dict(r) for r in rs]

@app.get("/documents/{doc_id}")
def get_document(doc_id: int) -> Dict[str, Any]:
    with engine.begin() as conn:
        row = conn.execute(
            text("""SELECT id, filename, mime, folder_id, created_at
                    FROM documents WHERE id=:i"""),
            {"i": doc_id},
        ).mappings().first()
        if not row:
            raise HTTPException(404, "Document not found")
        return dict(row)

@app.get("/documents/{doc_id}/download")
def download_document(doc_id: int):
    with engine.begin() as conn:
        row = conn.execute(
            text("""SELECT filename, mime, content
                    FROM documents WHERE id=:i"""),
            {"i": doc_id},
        ).mappings().first()
        if not row:
            raise HTTPException(404, "Document not found")

        filename = row["filename"] or f"document-{doc_id}"
        mime = row["mime"] or "application/octet-stream"
        content = row["content"] or ""

        if content.startswith("base64:"):
            data = base64.b64decode(content[7:])
            return Response(
                content=data, media_type=mime,
                headers={"Content-Disposition": f'attachment; filename="{filename}"'}
            )
        else:
            data = content.encode("utf-8")
            # si c'est vraiment du texte, on laisse le mime tel quel ou text/plain
            mt = mime if mime.startswith("text/") else "text/plain; charset=utf-8"
            return Response(
                content=data, media_type=mt,
                headers={"Content-Disposition": f'attachment; filename="{filename}"'}
            )

